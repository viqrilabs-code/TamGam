# app/schemas/note.py
# Pydantic request/response models for AI notes endpoints

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel


# ── Note Content Structure ────────────────────────────────────────────────────
# Stored as JSONB in DB -- this is the shape of note.content

class QAPair(BaseModel):
    question: str
    answer: str


class NoteContent(BaseModel):
    """
    Structured note content generated by Gemini.
    Stored as JSONB in notes.content column.
    """
    summary: str                          # 2-3 sentence class summary
    key_points: List[str]                 # 5-8 bullet points
    detailed_notes: str                   # Full markdown notes
    qa_pairs: List[QAPair]                # 3-5 Q&A pairs for self-testing


# ── Note Response ─────────────────────────────────────────────────────────────

class NoteResponse(BaseModel):
    id: UUID
    class_id: UUID
    status: str              # pending | generating | completed | failed | rejected
    content: Optional[NoteContent] = None   # None if not yet generated or gated
    content_gated: bool      # True = content exists but hidden (no subscription)
    teacher_reviewed: bool
    teacher_review_notes: Optional[str] = None
    ai_model_used: Optional[str] = None
    generation_prompt_tokens: Optional[int] = None
    generation_output_tokens: Optional[int] = None
    created_at: datetime
    updated_at: datetime


# ── Requests ──────────────────────────────────────────────────────────────────

class NoteReviewRequest(BaseModel):
    """Teacher approves or rejects AI-generated notes."""
    approved: bool
    review_notes: Optional[str] = None   # Required if rejected


class NoteEditRequest(BaseModel):
    """Teacher edits the note content directly."""
    content: NoteContent


# ── Generic ───────────────────────────────────────────────────────────────────

class MessageResponse(BaseModel):
    message: str
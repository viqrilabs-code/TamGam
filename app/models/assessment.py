# app/models/assessment.py
# Adaptive assessment results per student per class
# Understanding level (1-5) per student per subject

import uuid
from datetime import datetime, timezone

from sqlalchemy import (
    Column,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship

from app.db.base_class import Base


class StudentAssessment(Base):
    """
    One adaptive assessment per student per class.
    Generated by Gemini, served to the student after notes are published.

    Question distribution (from product spec):
        ~40% below standard → confidence building (+2 pts each)
        ~40% at standard    → core understanding (+3 pts each)
        ~20% above standard → stretch goals (+4 pts each)

    JSON structure of `questions` field:
    [
        {
            "id": 1,
            "text": "What is the derivative of sin(x)?",
            "type": "mcq",          # mcq | short_answer | true_false
            "band": "at_level",     # below | at_level | above
            "options": ["cos(x)", "-cos(x)", "sin(x)", "-sin(x)"],
            "answer": "cos(x)",
            "explanation": "By the standard derivative formula...",
            "hint": "Think about the unit circle..."
        }
    ]
    """
    __tablename__ = "student_assessments"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    student_id = Column(
        UUID(as_uuid=True),
        ForeignKey("student_profiles.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    class_id = Column(
        UUID(as_uuid=True),
        ForeignKey("classes.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    # ── Questions & Answers ───────────────────────────────────────────────────
    questions = Column(JSONB, nullable=True)                  # Array of question objects (see above)
    student_answers = Column(JSONB, nullable=True)            # {"question_id": "student_answer"}
    total_questions = Column(Integer, nullable=True)

    # ── Scoring ───────────────────────────────────────────────────────────────
    score = Column(Float, nullable=True)                      # Raw score
    max_score = Column(Float, nullable=True)                  # Maximum possible score
    percentage = Column(Float, nullable=True)                 # score / max_score * 100

    # ── Per-band breakdown ────────────────────────────────────────────────────
    below_correct = Column(Integer, nullable=True, default=0)
    at_level_correct = Column(Integer, nullable=True, default=0)
    above_correct = Column(Integer, nullable=True, default=0)

    # ── Status ────────────────────────────────────────────────────────────────
    status = Column(
        Enum(
            "pending",     # Not yet started by student
            "in_progress", # Student started but not submitted
            "submitted",   # Student submitted answers
            "evaluated",   # Score computed
            "expired",     # Time limit exceeded without submission
            name="assessment_status_enum",
        ),
        nullable=False,
        default="pending",
        index=True,
    )

    # ── Timing ────────────────────────────────────────────────────────────────
    time_limit_seconds = Column(Integer, nullable=False, default=300)  # 5 min default
    started_at = Column(DateTime(timezone=True), nullable=True)
    submitted_at = Column(DateTime(timezone=True), nullable=True)

    # ── Level Used for Generation ─────────────────────────────────────────────
    # Level at the time of generation (for historical analysis)
    level_at_generation = Column(Integer, nullable=True)      # 1–5

    created_at = Column(
        DateTime(timezone=True),
        nullable=False,
        default=lambda: datetime.now(timezone.utc),
    )

    # ── Relationships ─────────────────────────────────────────────────────────
    student = relationship("StudentProfile", back_populates="assessments")
    class_ = relationship("Class", back_populates="assessments")

    def __repr__(self) -> str:
        return (
            f"<StudentAssessment student={self.student_id} "
            f"class={self.class_id} score={self.score}>"
        )


class StudentUnderstandingProfile(Base):
    """
    Current understanding level (1-5) per student per subject.
    Recomputed every 3 classes as a moving average.

    Levels:
        1 → Patient, analogies, micro-steps, real-world examples
        2 → Simple language, worked examples, gentle hints
        3 → Standard explanations, conceptual depth (most students)
        4 → Concise, advanced patterns, competitive exam focus
        5 → Peer-level, proofs, edge cases, research thinking

    Used by:
        - AI Tutor (Diya) to calibrate response style
        - Assessment generator to set question difficulty
        - Teacher dashboard heatmap
    """
    __tablename__ = "student_understanding_profiles"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    student_id = Column(
        UUID(as_uuid=True),
        ForeignKey("student_profiles.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    subject = Column(String(100), nullable=False)             # "Mathematics" | "Science" etc.
    current_level = Column(Integer, nullable=False, default=3)  # 1–5
    previous_level = Column(Integer, nullable=True)           # For trend tracking

    # ── Computation Metadata ──────────────────────────────────────────────────
    classes_since_last_recompute = Column(Integer, nullable=False, default=0)
    total_classes_assessed = Column(Integer, nullable=False, default=0)
    last_recomputed_at = Column(DateTime(timezone=True), nullable=True)

    # ── Score History (last N assessments) ────────────────────────────────────
    recent_scores = Column(JSONB, nullable=True)              # [{"class_id": ..., "score": ...}]

    created_at = Column(
        DateTime(timezone=True),
        nullable=False,
        default=lambda: datetime.now(timezone.utc),
    )
    updated_at = Column(
        DateTime(timezone=True),
        nullable=False,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
    )

    # ── Relationships ─────────────────────────────────────────────────────────
    student = relationship("StudentProfile", back_populates="understanding_profiles")

    def __repr__(self) -> str:
        return (
            f"<StudentUnderstandingProfile "
            f"student={self.student_id} subject={self.subject} level={self.current_level}>"
        )